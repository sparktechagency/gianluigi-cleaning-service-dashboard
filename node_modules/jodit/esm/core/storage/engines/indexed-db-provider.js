/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Released under MIT see LICENSE.txt in the project root for license information.
 * Copyright (c) 2013-2026 Valerii Chupurnov. All rights reserved. https://xdsoft.net
 */
import { IS_PROD } from "../../constants.js";
/**
 * Persistent storage using IndexedDB
 */
export class IndexedDBProvider {
    constructor(dbName = 'JoditDB', storeName = 'keyValueStore') {
        this.dbName = dbName;
        this.dbPromise = null;
        this.DB_VERSION = 1;
        this.storeName = storeName;
    }
    /**
     * Initialize or get the database connection
     */
    getDB() {
        if (this.dbPromise) {
            return this.dbPromise;
        }
        this.dbPromise = new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.DB_VERSION);
            request.onerror = () => {
                reject(request.error);
            };
            request.onsuccess = () => {
                resolve(request.result);
            };
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(this.storeName)) {
                    db.createObjectStore(this.storeName);
                }
            };
        });
        return this.dbPromise;
    }
    /**
     * Perform a transaction on the store
     */
    async performTransaction(mode, callback) {
        try {
            const db = await this.getDB();
            const transaction = db.transaction([this.storeName], mode);
            const store = transaction.objectStore(this.storeName);
            const request = callback(store);
            return new Promise((resolve, reject) => {
                request.onsuccess = () => {
                    resolve(request.result);
                };
                request.onerror = () => {
                    reject(request.error);
                };
            });
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    async set(key, value) {
        try {
            await this.performTransaction('readwrite', store => store.put(value, key));
        }
        catch (e) {
            if (!IS_PROD) {
                console.error(e);
            }
        }
        return this;
    }
    async delete(key) {
        try {
            await this.performTransaction('readwrite', store => store.delete(key));
        }
        catch (_a) { }
        return this;
    }
    async get(key) {
        try {
            return await this.performTransaction('readonly', store => store.get(key));
        }
        catch (_a) {
            return undefined;
        }
    }
    async exists(key) {
        try {
            const result = await this.performTransaction('readonly', store => store.get(key));
            return result !== undefined;
        }
        catch (_a) {
            return false;
        }
    }
    async clear() {
        try {
            await this.performTransaction('readwrite', store => store.clear());
        }
        catch (_a) { }
        return this;
    }
    /**
     * Close the database connection
     */
    async close() {
        if (this.dbPromise) {
            try {
                const db = await this.dbPromise;
                db.close();
            }
            catch (_a) { }
            this.dbPromise = null;
        }
    }
    /**
     * Get all keys in the store
     */
    async keys() {
        try {
            let result = await this.performTransaction('readonly', store => store.getAllKeys());
            // Handle case where result might be a promise
            if (result && typeof result === 'object' && 'then' in result) {
                result = await result;
            }
            return result.map(k => String(k));
        }
        catch (_a) {
            return [];
        }
    }
    /**
     * Get all values in the store
     */
    async values() {
        try {
            let result = await this.performTransaction('readonly', store => store.getAll());
            // Handle case where result might be a promise
            if (result && typeof result === 'object' && 'then' in result) {
                result = await result;
            }
            return result;
        }
        catch (_a) {
            return [];
        }
    }
    /**
     * Get all entries (key-value pairs) in the store
     */
    async entries() {
        try {
            const [keys, values] = await Promise.all([
                this.keys(),
                this.values()
            ]);
            return keys.map((key, index) => [key, values[index]]);
        }
        catch (_a) {
            return [];
        }
    }
}
let cachedResult = null;
export function clearUseIndexedDBCache() {
    cachedResult = null;
}
/**
 * Check if IndexedDB is available
 */
export async function canUseIndexedDB() {
    if (cachedResult != null) {
        return cachedResult;
    }
    try {
        if (typeof indexedDB === 'undefined') {
            cachedResult = false;
            return false;
        }
        const tmpKey = '___Jodit___' + Math.random().toString();
        const request = indexedDB.open(tmpKey);
        cachedResult = await new Promise(resolve => {
            request.onerror = () => {
                resolve(false);
            };
            request.onsuccess = () => {
                indexedDB.deleteDatabase(tmpKey);
                resolve(true);
            };
        });
        return cachedResult;
    }
    catch (_a) {
        cachedResult = false;
        return false;
    }
}
